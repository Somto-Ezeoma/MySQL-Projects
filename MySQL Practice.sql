
-- SELECT STATMENT 
-- USED TO FETCH COLUMN(S) FROM A TABLE 

-- FETCH ALL THE COLUMNS 
-- WE USE THE  * AFTER THE SELECT STATEMENT 
SELECT * FROM PAYMENTS;

SELECT * FROM ORDERS;

-- FETCH SPECIFIC COLUMNS 
-- WE ADD THE NAMES OF THE COUMNS AFTER THE SELECT STATEMENT 
SELECT ORDERNUMBER, STATUS FROM ORDERS;


-- REMOVING DUPICATE RECORDS 
-- DISTINCT ==> KEYWRD USED TO REMOVE DUPLICATE RECORDS 

SELECT * FROM EMPLOYEES;
SELECT JOBTITLE FROM EMPLOYEES;
SELECT DISTINCT JOBTITLE FROM EMPLOYEES;

-- FILTERING RECORDS

-- GET THE ALL THE INFO OF THE CUSTOMER(S) WHOSE CONTACTFIRSTNAME IS JULIE
SELECT * FROM CUSTOMERS
WHERE CONTACTFIRSTNAME = 'JULIE';

-- GET ALL THE INFO OF THE CUSTOMER(S) WHOSE CONTACTFIRSTNAME IS  JULIE AND LASTNAME IS KING

SELECT * FROM CUSTOMERS 
WHERE CONTACTFIRSTNAME = 'JULIE' AND CONTACTLASTNAME = 'KING';

-- GET THE PAYMENTS GREATER THAN $100000
SELECT * FROM PAYMENTS
WHERE AMOUNT > 100000;

-- One of our customers, Baane Mini Imports, need to know who their contact person is. 
-- get this person NAMES and their  city;
SELECT CONTACTFIRSTNAME, CONTACTLASTNAME, CITY FROM CUSTOMERS 
WHERE CUSTOMERNAME = "BAANE MINI IMPORTS";

-- PREDICATES 
-- ARE CALLED ADVANCED FILTERS 
-- THERE ARE THREE OF THEM ==> BETWEEN, IN, LIKE 

-- BETWEEN 
-- USED TO FILTER WITHIN RANGE OF CALUES 
-- USED TO REPACE THE '>= AND <=' IN A STATEMENT 

-- GET THE CUSTOMERNUMBER, CHECKNUMBER AND AMOUNTS FOR PAYMENTS THAT ARE BETWEEN $8000 AND $9000
SELECT CUSTOMERNUMBER, CHECKNUMBER, AMOUNT FROM PAYMENTS
WHERE AMOUNT BETWEEN 8000 AND 9000;


-- IN 
-- USED TO FILTER MULTIPLE RECORD FROM A SINGLE COLUMN

-- Suppose I want to  find the offices located in the USA and France 
SELECT * FROM OFFICES 
WHERE COUNTRY = 'USA' OR COUNTRY = 'FRANCE';

SELECT * FROM OFFICES 
WHERE COUNTRY IN ('USA', 'FRANCE');

-- LIKE 
-- USED FOR PATTERN FILTERING 
-- WORKS WITH TWO SYMBOLS 

-- _ ==> USED TO FILTER FOR ONE CHARACTER AT A TIME 
-- % ==> USED TO FILTER MORE THAN ONE CHARACTER AT A TIME 

-- GET THE FULL CONTACT NAMES OF CUSTOMERS WTH FIRST NAME STARTING WITH 'Je'
SELECT CONTACTFIRSTNAME, CONTACTLASTNAME FROM CUSTOMERS
WHERE CONTACTFIRSTNAME LIKE 'JE%';

--  CUSTOMERS WITH lastname  ending WITH 'on'
SELECT CONTACTFIRSTNAME, CONTACTLASTNAME FROM CUSTOMERS
WHERE CONTACTLASTNAME LIKE '%ON';

--  CUSTOMERS WITH lastname  ending WITH 'on' and firstname is susan 

SELECT CONTACTFIRSTNAME, CONTACTLASTNAME FROM CUSTOMERS
WHERE CONTACTFIRSTNAME = 'SUSAN' AND CONTACTLASTNAME LIKE '%ON';


-- SORTING RECORDS 
-- USED TO ARRANGE RECORDS EITHER NUMERICAL OR ALPHABETICAL 
-- ORDER BY ==> SYNTAX USED 
-- WE CAN SORT IN TWO WAYS 
-- ASCENDING, ASC ==> SMALLEST TO THE BIGGEST, 0-9, A-Z
-- DESCENDING, DESC==> BIGGEST TO THE SMALLEST, 9-0, Z

SELECT CONTACTFIRSTNAME, CONTACTLASTNAME FROM CUSTOMERS
ORDER BY CONTACTFIRSTNAME ASC;

SELECT CUSTOMERNUMBER, CHECKNUMBER, AMOUNT FROM PAYMENTS
ORDER BY AMOUNT DESC;

-- LIMITING RECORDS 
-- USED TO REDUCE THE AMOUT OF ROWS DISPLAYED 
-- LIMIT N ==> KEYWORD USED TO LIMIT RECORDS
-- N ==> NUMBER OF RECORDS WE WANT DISPLAYED  

SELECT CUSTOMERNUMBER, CHECKNUMBER, AMOUNT FROM PAYMENTS
ORDER BY AMOUNT DESC
LIMIT 5;

-- AGGREAGATE FUNCTIONS 
-- USED TO PERFORM SIMPLE STATISTICAL OPERATIONS 

-- MIN ==> USED TO RETURN THE MINIMUM VALUE IN A COLUMN 
SELECT MIN(AMOUNT) FROM PAYMENTS;

-- MAX ==> USED TO RETURN THE MAXIMUM VALUE IN A COLUMN 
SELECT MAX(AMOUNT) FROM PAYMENTS;

-- SUM ==> GIVES THE SUMMATION AMOUNT OF ALL THE VALUES IN A COLUMN 
SELECT SUM(AMOUNT) FROM PAYMENTS;

-- AVG ==> RETURNS THE AVERAGE MEAN OF VALLUES IN A COLUMN
SELECT AVG(AMOUNT) FROM PAYMENTS;

-- COUNT ==> RETURNS THE FREQUENCY OR COUNT OF VALUES IN A COLUMN 
SELECT COUNT(AMOUNT) FROM PAYMENTS;


-- ALIASES 
-- THIS IS THE RENAMING OF COLUMNS TO DESIRED ONES 
-- AS  ==> USED TO ALIAS
SELECT COUNT(AMOUNT) FROM PAYMENTS;

SELECT COUNT(AMOUNT) AS NO_OF_TRANSACTION FROM PAYMENTS;

SELECT CONTACTFIRSTNAME AS FIRSTNAME FROM CUSTOMERS;


-- GROUPING RECORDS 
-- GROUP BY ==> USED TO GROUP RECORDS 

SELECT * FROM PAYMENTS;
SELECT CUSTOMERNUMBER, AMOUNT FROM PAYMENTS;

-- HOW MUCH HAS EACH CUSTOMER SPENT 
SELECT CUSTOMERNUMBER, SUM(AMOUNT) AS TOTAL_AMOUNT FROM PAYMENTS
GROUP BY CUSTOMERNUMBER;

-- How many customers do we have from each country?
SELECT COUNT(CUSTOMERNUMBER) AS NO_OF_CUSTOMERS, COUNTRY FROM CUSTOMERS
GROUP BY COUNTRY;

SELECT COUNTRY, COUNT(CUSTOMERNUMBER) AS NO_OF_CUSTOMERS FROM CUSTOMERS
GROUP BY COUNTRY
ORDER BY NO_OF_CUSTOMERS DESC;

-- TOP 5 COUNTRIES BASED ON CUSTOMERS 
SELECT COUNTRY, COUNT(CUSTOMERNUMBER) AS NO_OF_CUSTOMERS FROM CUSTOMERS
GROUP BY COUNTRY
ORDER BY NO_OF_CUSTOMERS DESC
LIMIT 5;


-- FILTERING GROUPED RECORDS 
-- HAVING ==> USED TO FILTER GROUPED RECORDS 
-- WORKS JUST LIKE WHERE
-- IT WORKS WITH OPERATORS (>,<,AND ETC) AND PREDICATES (BETWEEN, IN, LIKE)

 -- WE WANT CUTOMERS WHO HAVE SPENT OVER $100,000
SELECT CUSTOMERNUMBER, SUM(AMOUNT) AS TOTAL_AMOUNT FROM PAYMENTS
GROUP BY CUSTOMERNUMBER
HAVING SUM(AMOUNT) > 100000;

 -- WE WANT CUTOMERS WHO HAVE SPENT BETWEEN $100,000 AND $200,000
SELECT CUSTOMERNUMBER, SUM(AMOUNT) AS TOTAL_AMOUNT FROM PAYMENTS
GROUP BY CUSTOMERNUMBER
HAVING SUM(AMOUNT) BETWEEN 100000 AND 200000
ORDER BY TOTAL_AMOUNT ASC;

-- JOINS 
-- USED TO COMBINE TWO OR TABLES TOGETHER 

-- HOW TO JOIN 

-- 01 IDENTIFY THE TABLES WE ARE JOINING 
-- 02 TAKE NOTE OF THE RELATIONSHIP KEYS (PRIMARY & FOREIGN KEYS)
-- 03 TAKE NOTE OF THE COLUMNS NEEDED AND THE TABLE THE COLUMNS APPEAR 
-- 04 MERGE THE COLUMNS TOGETHER IN A SINGLE SELECT STATEMENT
-- 05 STATE THE JOIN TYPE AFTER THE FROM KEYWORD
-- 06 ADD THE SECOND TABLE 
-- 07 INTRODUCE THE JOINING CONDITION = (ON) WITH RELATIONSHIP
-- 08 TO AVOID AMBIGOUS COLUMN:
	-- WE CAN ALIAS OUR TABLES NAMES 
	-- WE USE THE TABLE.COLUMNNAME FOR THE AMBIGOUS COLUMN

-- INNER
-- lets get the names of customers that patronizes the company
-- CUSTOMERS 
SELECT * FROM CUSTOMERS;
-- CUSTOMERNAME, CUSTOMERNUMBER
-- PAYMENTS
SELECT * FROM PAYMENTS;
-- CUSTOMERNUMBER, AMOUNT 

-- RELATIONSHIP: CUSTOMERNUMBER
-- -----------
SELECT CUSTOMERNAME, C.CUSTOMERNUMBER, P.CUSTOMERNUMBER, AMOUNT 
FROM CUSTOMERS AS C
INNER JOIN PAYMENTS AS P
ON C.CUSTOMERNUMBER = P.CUSTOMERNUMBER;


-- LEFT JOIN
SELECT CUSTOMERNAME, C.CUSTOMERNUMBER, P.CUSTOMERNUMBER, AMOUNT 
FROM CUSTOMERS AS C
LEFT JOIN PAYMENTS AS P
ON C.CUSTOMERNUMBER = P.CUSTOMERNUMBER;



-- UNIONS 
-- USED TO MERGE TWO OR MORE SEELCT STATEMENT TOGETHER 

-- RULES
-- 1.	Both queries must return the same number of columns
-- 2.	The corresponding columns in the queries must have compatible data types

-- UNION ==> MERGES WITHOUT DUPLICATE 
-- UNION ALL ==> MERGES WITH THE DUPLICATES

-- Suppose that you want to combine the first name and 
-- last name of employees and customers CONTACTS into a single result set,
SELECT LASTNAME, FIRSTNAME FROM EMPLOYEES
UNION
SELECT CONTACTLASTNAME, CONTACTFIRSTNAME FROM CUSTOMERS;


SELECT LASTNAME, FIRSTNAME FROM EMPLOYEES
UNION ALL
SELECT CONTACTLASTNAME, CONTACTFIRSTNAME FROM CUSTOMERS;

-- CREATING TABLES 
-- STEPS TO FOLLOW 

-- USE THE KEYWORD ==> CREATE TABLE TABLENAME()
-- WITHIN THE BRACKET, YOU ADD YOUR COLUMNS 
-- YOU SPECIFY THE DATATYPES FOR THE COLUMNS 
	-- DATATYPES: NUMERICAL ==> INT, FLOAT
			-- CHARACTER BASED ==> VARCHAR(10), CHAR(10)
			-- DATES: DATE, DATETIME, TIME
-- YOU SPECIFY THE CONSTRAINTS ON EACH COLUMNS 
	-- ARE RULES GUIDING A COLUMN 
	-- UNIQUE: EACH OF THE ROWS ARE UNIQUE	
	-- NOT NULL: THE COLUMN MUST NOT ACCEPT NULL VALUES
	-- PRIMARY KEY: UNIQUE + NOTNULL
-- LETC CREATE A TABLE FOR THE CLASS 
CREATE TABLE JULY_COHORT(
	STUDENTID INT PRIMARY KEY,
    NAME VARCHAR(25) NOT NULL,
    GENDER CHAR(1) NOT NULL,
    LOCATION VARCHAR(25) NOT NULL
);

SELECT * FROM july_cohort;

-- INSERTING RECORDS INTO TABLES 

-- STEPS TO FOLLOW 
-- USE THE KEYWORD ==> INSERT INTO TABLENAME()
-- WITHIN THE BRACKET, YOU ADD THE COLUMNS THAT WE WANT INSERT INTO 
-- AD DTHE KEYWORD VALUES() TO INITIALISE ADDING VALUES 
-- IN THE BRACKET, YOU ADD THE CORRESPONNDING VALUES FOR THE COLUMNS 

INSERT INTO JULY_COHORT
(STUDENTID, NAME, GENDER, LOCATION)
VALUES
(1, 'SOMTOCHUKWU', 'F', 'UK'),
(2, 'UMAR', 'M', 'NIGERIA'),
(3, 'OLUWAFEMI', 'M', 'UK'),
(4, 'MATHEW', 'M', 'NIGERIA'),
(5, 'UCHE', 'M', 'RUSSIA'),
(6, 'BARO', 'M', 'NIGERIA')

